<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Category detection practical</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://stackedit.io/libs/MathJax/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h1 id="object-category-detection-practical">Object category detection practical</h1>

<p>This is an <a href="http://www.robots.ox.ac.uk/~vgg">Oxford Visual Geometry Group</a> computer vision practical, authored by <a href="http://www.robots.ox.ac.uk/~vedaldi/">Andrea Vedaldi</a> and Andrew Zisserman (Release 2014a).</p>

<p><img src="images/cover.jpeg" alt="cover" title="cover.jpeg"></p>

<p>The goal of <em>object category detection</em> is to identify and localize objects of a given type in an image. Examples applications include detecting pedestrian, cars, or traffic signs in street signs, objects of interest such as tools or animals in web images, or particular features in medical image. Given a target class, such as <em>people</em>, a <em>detector</em> receives as input an image and produces as output zero, one, or more bounding boxes around each occurrence of the object class in the image. The key challenge is that the detector needs to find objects regardless of their location and scale in the image, as well as pose and other variation factors, such as clothing, illumination, occlusions, etc.</p>

<p>This practical explores basic techniques in visual object detection, focusing on  <em>image based models</em>. The appearance of image patches containing objects is learned using statistical analysis. Then, in order to detect objects in an image, the statistical model is applied to image windows extracted at all possible scales and locations, in order to identify which ones, if any, contain the object.</p>

<p>In more detail, the practical explores the following topics: (i) using HOG features to describe image regions, (ii) building a HOG-based sliding-window detector to localize objects in images; (iii) working with multiple scales and multiple object occurrences; (iv) using a linear support vector machine to learn the appearance of objects; (v) evaluating an object detector in term of average precision; (vi) learning an object detector using hard negative mining.</p>

<p><div class="toc">
<ul>
<li><a href="#object-category-detection-practical">Object category detection practical</a><ul>
<li><a href="#getting-started">Getting started</a></li>
<li><a href="#part1">Part 1: Detection fundamentals</a><ul>
<li><a href="#step-10-loading-the-training-data">Step 1.0: Loading the training data</a></li>
<li><a href="#step-11-visualize-the-training-images">Step 1.1: Visualize the training images</a></li>
<li><a href="#step-12-extract-hog-features-from-the-training-images">Step 1.2: Extract HOG features from the training images</a></li>
<li><a href="#step-13-learn-a-simple-hog-template-model">Step 1.3: Learn a simple HOG template model</a></li>
<li><a href="#step-14-apply-the-model-to-a-test-image">Step 1.4: Apply the model to a test image</a></li>
<li><a href="#step-15-extract-the-top-detection">Step 1.5: Extract the top detection</a></li>
</ul>
</li>
<li><a href="#part2">Part 2: Multiple scales and learning with an SVM</a><ul>
<li><a href="#step2">Step 2.1: Multi-scale detection</a></li>
<li><a href="#step-22-collect-positive-and-negative-training-data">Step 2.2: Collect positive and negative training data</a></li>
<li><a href="#step-23-learn-a-model-with-an-svm">Step 2.3: Learn a model with an SVM</a></li>
<li><a href="#step-24-evaluate-the-learned-model">Step 2.4: Evaluate the learned model</a></li>
</ul>
</li>
<li><a href="#part3">Part 3: Multiple objects and evaluation</a><ul>
<li><a href="#step-31-multiple-detections">Step 3.1: Multiple detections</a></li>
<li><a href="#step-32-detector-evaluation">Step 3.2: Detector evaluation</a></li>
<li><a href="#step-33-evaluation-on-multiple-images">Step 3.3: Evaluation on multiple images</a></li>
</ul>
</li>
<li><a href="#part4">Part 4: Hard negative mining</a><ul>
<li><a href="#stage4">Step 4.1: Train with hard negative mining</a></li>
<li><a href="#step-42-evaluate-the-model-on-the-test-data">Step 4.2: Evaluate the model on the test data</a></li>
</ul>
</li>
<li><a href="#part-5-train-your-own-object-detector">Part 5: Train your own object detector</a><ul>
<li><a href="#step-51-preparing-the-training-data">Step 5.1: Preparing the training data</a></li>
<li><a href="#step-52-learn-the-model">Step 5.2: Learn the model</a></li>
<li><a href="#step-53-test-the-model">Step 5.3: Test the model</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</p>

<h2 id="getting-started">Getting started</h2>

<p>Read and understand the <a href="http://www.robots.ox.ac.uk/~vgg/practicals/instance-recognition/index.html#installation">requirements and installation instructions</a>. The download links for this practical are:</p>

<ul>
<li>Code and data: <a href="http://www.robots.ox.ac.uk/~vgg/share/practical-category-detection-2014a.tar.gz">practical-category-detection-2014a.tar.gz</a></li>
<li>Code only: <a href="http://www.robots.ox.ac.uk/~vgg/share/practical-category-detection-2014a-code-only.tar.gz">practical-category-detection-2014a-code-only.tar.gz</a></li>
<li>Data only: <a href="http://www.robots.ox.ac.uk/~vgg/share/practical-category-detection-2014a-data-only.tar.gz">practical-category-detection-2014a-data-only.tar.gz</a></li>
<li><a href="https://github.com/vedaldi/practical-object-category-detection">Git repository</a> (for lab setters and developers)</li>
</ul>

<p>After the installation is complete, open and edit the script <code>exercise1.m</code> in the MATLAB editor. The script contains commented code and a description for all steps of this exercise, relative to <a href="#part1">Part I</a> of this document. You can cut and paste this code into the MATLAB window to run it, and will need to modify it as you go through the session. Other files <code>exercise2.m</code>, <code>exercise3.m</code>, and <code>exercise4.m</code> are given for <a href="#part2">Part II</a>, <a href="#part3">III</a>, and <a href="part4">IV</a>.</p>

<p>Each part contains several <strong>Questions</strong> and <strong>Tasks</strong> to be answered/completed before proceeding further in the practical.</p>

<h2 id="part1">Part 1: Detection fundamentals</h2>

<p>In Part I–IV use as running example the problem of street sign detection, using the data from the <a href="http://benchmark.ini.rub.de/?section=gtsdb&amp;subsection=news">German Traffic Sign Detection Benchmark</a>. This data consists of a number of example traffic images, as well as a number of larger test images containing one or more traffic signs at different sizes and locations. It also comes with <em>ground truth</em> annotation, i.e. with specified bounding boxes and sign labels for each sign occurrence, which is required to evaluate the quality of the detector.</p>

<p>In this part we will build a basic sliding-window object detector based on HOG features. Follow the steps below:</p>

<h3 id="step-10-loading-the-training-data">Step 1.0: Loading the training data</h3>

<p>The MATLAB m-file <code>loadData.m</code> loads the data relative to the practical into memory. The function <code>loadData(targetClass)</code> takes a <code>targetClass</code> argument specifying the object class of interest. Open the <code>example1.m</code> file, select the following part of the code, and execute it in MATLAB (right button &gt; <em>Evaluate selection</em> or Shift+F7).</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Load the training and testing data (trainImages, trainBoxes, ...)</span>
<span class="hljs-comment">% The functio takes the ID of the type of traffic sign we want to recognize</span>
<span class="hljs-comment">% 1 is the 30 km/h speed limit</span>
loadData(<span class="hljs-number">1</span>) ;</code></pre>

<p>This loads into the current workspace the following variables:</p>

<ul>
<li><code>trainImages</code>: a list of train image names.</li>
<li><code>trainBoxes</code>: a <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-25-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-187" style="width: 2.875em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.361em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.685em 1000em 2.74em -0.519em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-188"><span class="mn" id="MathJax-Span-189" style="font-family: STIXGeneral-Regular;">4</span><span class="mo" id="MathJax-Span-190" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="mi" id="MathJax-Span-191" style="font-family: STIXGeneral-Italic; padding-left: 0.25em;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.06em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.991em; vertical-align: -0.102em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-25">4\times N</script> array of object bounding boxes, in the form <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-26-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-192" style="width: 10.732em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.855em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.699em 1000em 2.964em -0.443em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-193"><span class="mo" id="MathJax-Span-194" style="font-family: STIXGeneral-Regular;">[</span><span class="msubsup" id="MathJax-Span-195"><span style="display: inline-block; position: relative; width: 1.666em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.726em -0.558em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-196" style="font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.469em;"><span class="mtext" id="MathJax-Span-197" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">min</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-198" style="font-family: STIXGeneral-Regular;">,</span><span class="msubsup" id="MathJax-Span-199" style="padding-left: 0.188em;"><span style="display: inline-block; position: relative; width: 1.669em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.921em -0.555em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-200" style="font-family: STIXGeneral-Italic;">y</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -1.943em; left: 0.472em;"><span class="mtext" id="MathJax-Span-201" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">min</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-202" style="font-family: STIXGeneral-Regular;">,</span><span class="msubsup" id="MathJax-Span-203" style="padding-left: 0.188em;"><span style="display: inline-block; position: relative; width: 1.784em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.726em -0.558em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-204" style="font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.469em;"><span class="mtext" id="MathJax-Span-205" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">max</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-206" style="font-family: STIXGeneral-Regular;">,</span><span class="msubsup" id="MathJax-Span-207" style="padding-left: 0.188em;"><span style="display: inline-block; position: relative; width: 1.787em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.921em -0.555em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-208" style="font-family: STIXGeneral-Italic;">y</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -1.943em; left: 0.472em;"><span class="mtext" id="MathJax-Span-209" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">max</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-210" style="font-family: STIXGeneral-Regular;">]</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.244em; vertical-align: -0.372em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-26">[x_\text{min},y_\text{min},x_\text{max},y_\text{max}]</script>.</li>
<li><code>trainBoxImages</code>: for each bounding box, the name of the image containing it.</li>
<li><code>trainBoxLabels</code>: for each bounding box, the object label. It is one of the index in <code>targetClass</code>.</li>
<li><code>trainBoxPatches</code>: a <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-27-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-211" style="width: 8.018em; display: inline-block;"><span style="display: inline-block; position: relative; width: 6.612em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.677em 1000em 2.74em -0.497em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-212"><span class="mn" id="MathJax-Span-213" style="font-family: STIXGeneral-Regular;">64</span><span class="mo" id="MathJax-Span-214" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="mn" id="MathJax-Span-215" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">64</span><span class="mo" id="MathJax-Span-216" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="mn" id="MathJax-Span-217" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">3</span><span class="mo" id="MathJax-Span-218" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="mi" id="MathJax-Span-219" style="font-family: STIXGeneral-Italic; padding-left: 0.25em;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.06em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.001em; vertical-align: -0.102em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-27">64 \times 64 \times 3 \times N</script> array of image patches, one for each training object. Patches are in RGB format.</li>
</ul>

<p>An analogous set of variables <code>testImages</code>, <code>testBoxes</code>, and so on are provided for the test data. Familiraise yourself with the contents of these variables.</p>

<blockquote>
  <p><strong>Question:</strong> why is there a <code>trainImages</code> and a <code>trainBoxImages</code> variables?</p>
</blockquote>

<h3 id="step-11-visualize-the-training-images">Step 1.1: Visualize the training images</h3>

<p>Select now the part of the code relative to section 1.1 and execute it. This will create an image visualizing both the complete list of object training examples and their average.</p>

<blockquote>
  <p><strong>Question:</strong> what can you deduce about the object variability from the average image?</p>
</blockquote>

<h3 id="step-12-extract-hog-features-from-the-training-images">Step 1.2: Extract HOG features from the training images</h3>

<p>Object detectors usually work on top of a layer of low-level features. In this case, we use HOG (<em>histogram of oriented gradients</em>) features. In order to learn a model of the object, we start by extracting features from the image patches corresponding to the available training examples. This is done by the following <code>for</code> loop:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">hogCellSize = <span class="hljs-number">8</span> ;
trainHog = <span class="hljs-cell">{}</span> ;
<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(trainBoxPatches,<span class="hljs-number">4</span>)
  trainHog<span class="hljs-cell">{i}</span> = vl_hog(trainBoxPatches(:,:,:,<span class="hljs-built_in">i</span>), hogCellSize) ;
<span class="hljs-keyword">end</span>
trainHog = <span class="hljs-built_in">cat</span>(<span class="hljs-number">4</span>, trainHog<span class="hljs-cell">{:}</span>) ;</code></pre>

<p>HOG is computed by the <a href="http::www.vlfeat.org">VLFeat</a> function <code>vl_hog</code> (<a href="http://www.vlfeat.org/matlab/vl_hog.html">doc</a>). This function takes as parameter the size in pixels of each HOG cell <code>hogCellSize</code>. It also takes a RGB image, represented in MATLAB as a <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-28-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-220" style="width: 4.804em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.955em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.678em 1000em 2.74em -0.516em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-221"><span class="mi" id="MathJax-Span-222" style="font-family: STIXGeneral-Italic;">w</span><span class="mo" id="MathJax-Span-223" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="mi" id="MathJax-Span-224" style="font-family: STIXGeneral-Italic; padding-left: 0.25em;">h</span><span class="mo" id="MathJax-Span-225" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="mn" id="MathJax-Span-226" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">3</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1em; vertical-align: -0.102em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-28">w \times h \times 3</script> array (extracted as a slice of <code>trainBoxPatches</code>). The output is a <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-29-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-227" style="width: 20.089em; display: inline-block;"><span style="display: inline-block; position: relative; width: 16.588em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.678em 1000em 2.943em -0.516em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-228"><span class="mi" id="MathJax-Span-229" style="font-family: STIXGeneral-Italic;">w</span><span class="texatom" id="MathJax-Span-230"><span class="mrow" id="MathJax-Span-231"><span class="mo" id="MathJax-Span-232" style="font-family: STIXGeneral-Regular;">/</span></span></span><span class="texatom" id="MathJax-Span-233"><span class="mrow" id="MathJax-Span-234"><span class="mi" id="MathJax-Span-235" style="font-family: STIXGeneral-Regular;">𝚑</span><span class="mi" id="MathJax-Span-236" style="font-family: STIXGeneral-Regular;">𝚘</span><span class="mi" id="MathJax-Span-237" style="font-family: STIXGeneral-Regular;">𝚐</span><span class="mi" id="MathJax-Span-238" style="font-family: STIXGeneral-Regular;">𝙲</span><span class="mi" id="MathJax-Span-239" style="font-family: STIXGeneral-Regular;">𝚎</span><span class="mi" id="MathJax-Span-240" style="font-family: STIXGeneral-Regular;">𝚕</span><span class="mi" id="MathJax-Span-241" style="font-family: STIXGeneral-Regular;">𝚕</span><span class="mi" id="MathJax-Span-242" style="font-family: STIXGeneral-Regular;">𝚂</span><span class="mi" id="MathJax-Span-243" style="font-family: STIXGeneral-Regular;">𝚒</span><span class="mi" id="MathJax-Span-244" style="font-family: STIXGeneral-Regular;">𝚣</span><span class="mi" id="MathJax-Span-245" style="font-family: STIXGeneral-Regular;">𝚎</span></span></span><span class="mo" id="MathJax-Span-246" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="mi" id="MathJax-Span-247" style="font-family: STIXGeneral-Italic; padding-left: 0.25em;">h</span><span class="texatom" id="MathJax-Span-248"><span class="mrow" id="MathJax-Span-249"><span class="mo" id="MathJax-Span-250" style="font-family: STIXGeneral-Regular;">/</span></span></span><span class="texatom" id="MathJax-Span-251"><span class="mrow" id="MathJax-Span-252"><span class="mi" id="MathJax-Span-253" style="font-family: STIXGeneral-Regular;">𝚑</span><span class="mi" id="MathJax-Span-254" style="font-family: STIXGeneral-Regular;">𝚘</span><span class="mi" id="MathJax-Span-255" style="font-family: STIXGeneral-Regular;">𝚐</span><span class="mi" id="MathJax-Span-256" style="font-family: STIXGeneral-Regular;">𝙲</span><span class="mi" id="MathJax-Span-257" style="font-family: STIXGeneral-Regular;">𝚎</span><span class="mi" id="MathJax-Span-258" style="font-family: STIXGeneral-Regular;">𝚕</span><span class="mi" id="MathJax-Span-259" style="font-family: STIXGeneral-Regular;">𝚕</span><span class="mi" id="MathJax-Span-260" style="font-family: STIXGeneral-Regular;">𝚂</span><span class="mi" id="MathJax-Span-261" style="font-family: STIXGeneral-Regular;">𝚒</span><span class="mi" id="MathJax-Span-262" style="font-family: STIXGeneral-Regular;">𝚣</span><span class="mi" id="MathJax-Span-263" style="font-family: STIXGeneral-Regular;">𝚎</span></span></span><span class="mo" id="MathJax-Span-264" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="mn" id="MathJax-Span-265" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">31</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.245em; vertical-align: -0.347em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-29">w/\mathtt{hogCellSize} \times h/\mathtt{hogCellSize} \times 31</script> dimensional array. One such array is extracted for each example image end eventually these are concatenated in a 4D array along the fourth dimension.</p>

<h3 id="step-13-learn-a-simple-hog-template-model">Step 1.3: Learn a simple HOG template model</h3>

<p>A very basic object model can be obtained by averaging the features of the example objects. This is done by:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">w = mean(trainHog, <span class="hljs-number">4</span>) ;</code></pre>

<p>The model can be visualized by <em>rendering</em> <code>w</code> as if it was a HOG feature array. This can be done using the <code>render</code> option of <code>vl_hog</code>:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">figure(<span class="hljs-number">2</span>) ; clf ;
imagesc(vl_hog(<span class="hljs-string">'render'</span>, w)) ;</code></pre>

<p>Spend some time to study this plot and make sure you understand what is visualized.</p>

<blockquote>
  <p><strong>Question:</strong> Can you make sense of the resulting plot?</p>
</blockquote>

<h3 id="step-14-apply-the-model-to-a-test-image">Step 1.4: Apply the model to a test image</h3>

<p>The model is matched to a test image by: (i) extracting the HOG features of the image and (ii) convolving the model to the resulting feature map:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">im = imread(<span class="hljs-string">'data/signs-sample-image.jpg'</span>) ;
im = im2single(im) ;
hog = vl_hog(im, hogCellSize) ;
scores = vl_nnconv(hog, w, <span class="hljs-matrix">[]</span>) ;</code></pre>

<p>The first two lines read a sample image and conver it to single format. The third line computes the HOG features of the image using the <code>vl_hog</code> seen above. The fourth line convolves the HOG map <code>hog</code> with the model <code>w</code>. It uses the function <code>vl_nnconv</code><a href="#fn:nn" id="fnref:nn" title="See footnote" class="footnote">1</a> and returns a <code>scores</code> map.</p>

<blockquote>
  <p><strong>Task:</strong> Work out the dimension of the <code>scores</code> arrays. Then, check your result with the dimension of the array computed by MATLAB.</p>
  
  <p><strong>Question:</strong> Visualize the image <code>im</code> and the <code>scores</code> array using the provided example code. Does the result match your expectations?</p>
</blockquote>

<h3 id="step-15-extract-the-top-detection">Step 1.5: Extract the top detection</h3>

<p>Now that the model has been applied to the image, we have a response map <code>scores</code>. To extract a detection from this, we (i) find the maximum response and (ii) compute the bounding box of the image patch containing the corresponding HOG features. The maximum is found by:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-matrix">[best, bestIndex]</span> = max(scores(:)) ;</code></pre>

<p>Note that <code>bestIndex</code> is a linear index in the range <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-30-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-266" style="width: 3.018em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.479em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.685em 1000em 2.871em -0.443em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-267"><span class="mo" id="MathJax-Span-268" style="font-family: STIXGeneral-Regular;">[</span><span class="mn" id="MathJax-Span-269" style="font-family: STIXGeneral-Regular;">1</span><span class="mo" id="MathJax-Span-270" style="font-family: STIXGeneral-Regular;">,</span><span class="mi" id="MathJax-Span-271" style="font-family: STIXGeneral-Italic; padding-left: 0.188em;">M<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.039em;"></span></span><span class="mo" id="MathJax-Span-272" style="font-family: STIXGeneral-Regular;">]</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.15em; vertical-align: -0.26em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-30">[1, M]</script> where <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-31-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-273" style="width: 1.089em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.885em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.708em 1000em 2.715em -0.549em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-274"><span class="mi" id="MathJax-Span-275" style="font-family: STIXGeneral-Italic;">M<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.039em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.933em; vertical-align: -0.071em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-31">M</script> is the number of possible filter locations. We convert this into a subscript <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-32-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-276" style="width: 3.661em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.011em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.678em 1000em 3.011em -0.483em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-277"><span class="mo" id="MathJax-Span-278" style="font-family: STIXGeneral-Regular;">(</span><span class="msubsup" id="MathJax-Span-279"><span style="display: inline-block; position: relative; width: 0.96em; height: 0px;"><span style="position: absolute; clip: rect(1.678em 1000em 2.724em -0.512em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-280" style="font-family: STIXGeneral-Italic;">h</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.531em;"><span class="mi" id="MathJax-Span-281" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-282" style="font-family: STIXGeneral-Regular;">,</span><span class="msubsup" id="MathJax-Span-283" style="padding-left: 0.188em;"><span style="display: inline-block; position: relative; width: 0.96em; height: 0px;"><span style="position: absolute; clip: rect(1.678em 1000em 2.724em -0.512em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-284" style="font-family: STIXGeneral-Italic;">h</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.531em;"><span class="mi" id="MathJax-Span-285" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">y</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-286" style="font-family: STIXGeneral-Regular;">)</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.327em; vertical-align: -0.429em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-32">(h_x,h_y)</script> using MATLAB <code>ind2sub</code> function:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-matrix">[hy, hx]</span> = <span class="hljs-built_in">ind2sub</span>(<span class="hljs-built_in">size</span>(scores), bestIndex) ;</code></pre>

<p><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-33-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-287" style="width: 3.661em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.011em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.678em 1000em 3.011em -0.483em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-288"><span class="mo" id="MathJax-Span-289" style="font-family: STIXGeneral-Regular;">(</span><span class="msubsup" id="MathJax-Span-290"><span style="display: inline-block; position: relative; width: 0.96em; height: 0px;"><span style="position: absolute; clip: rect(1.678em 1000em 2.724em -0.512em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-291" style="font-family: STIXGeneral-Italic;">h</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.531em;"><span class="mi" id="MathJax-Span-292" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-293" style="font-family: STIXGeneral-Regular;">,</span><span class="msubsup" id="MathJax-Span-294" style="padding-left: 0.188em;"><span style="display: inline-block; position: relative; width: 0.96em; height: 0px;"><span style="position: absolute; clip: rect(1.678em 1000em 2.724em -0.512em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-295" style="font-family: STIXGeneral-Italic;">h</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.531em;"><span class="mi" id="MathJax-Span-296" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">y</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-297" style="font-family: STIXGeneral-Regular;">)</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.327em; vertical-align: -0.429em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-33">(h_x,h_y)</script> are in units of HOG cells. We convert this into pixel coordinates as follows:</p>

<pre class="prettyprint"><code class=" hljs ini"><span class="hljs-setting">x = <span class="hljs-value">(hx - <span class="hljs-number">1</span>) * hogCellSize + <span class="hljs-number">1</span> ;</span></span>
<span class="hljs-setting">y = <span class="hljs-value">(hy - <span class="hljs-number">1</span>) * hogCellSize + <span class="hljs-number">1</span> ;</span></span></code></pre>

<blockquote>
  <p><strong>Question:</strong> Why are we subtracting -1 and summing +1? Which pixel <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-34-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-298" style="width: 2.304em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.988em; height: 0px; font-size: 115%;"><span style="position: absolute; clip: rect(1.622em 1000em 2.877em -0.511em); top: -2.484em; left: 0em;"><span class="mrow" id="MathJax-Span-299"><span class="mo" id="MathJax-Span-300" style="font-family: STIXGeneral-Regular;">(</span><span class="mi" id="MathJax-Span-301" style="font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-302" style="font-family: STIXGeneral-Regular;">,</span><span class="mi" id="MathJax-Span-303" style="font-family: STIXGeneral-Italic; padding-left: 0.188em;">y</span><span class="mo" id="MathJax-Span-304" style="font-family: STIXGeneral-Regular;">)</span></span><span style="display: inline-block; width: 0px; height: 2.484em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.157em; vertical-align: -0.308em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-34">(x,y)</script> of the HOG cell <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-35-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-305" style="width: 3.304em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.857em; height: 0px; font-size: 115%;"><span style="position: absolute; clip: rect(1.615em 1000em 2.966em -0.511em); top: -2.484em; left: 0em;"><span class="mrow" id="MathJax-Span-306"><span class="mo" id="MathJax-Span-307" style="font-family: STIXGeneral-Regular;">(</span><span class="msubsup" id="MathJax-Span-308"><span style="display: inline-block; position: relative; width: 0.882em; height: 0px;"><span style="position: absolute; clip: rect(1.615em 1000em 2.68em -0.54em); top: -2.484em; left: 0em;"><span class="mi" id="MathJax-Span-309" style="font-family: STIXGeneral-Italic;">h</span><span style="display: inline-block; width: 0px; height: 2.484em;"></span></span><span style="position: absolute; top: -2.024em; left: 0.497em;"><span class="mi" id="MathJax-Span-310" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span style="display: inline-block; width: 0px; height: 2.174em;"></span></span></span></span><span class="mo" id="MathJax-Span-311" style="font-family: STIXGeneral-Regular;">,</span><span class="msubsup" id="MathJax-Span-312" style="padding-left: 0.188em;"><span style="display: inline-block; position: relative; width: 0.882em; height: 0px;"><span style="position: absolute; clip: rect(1.615em 1000em 2.68em -0.54em); top: -2.484em; left: 0em;"><span class="mi" id="MathJax-Span-313" style="font-family: STIXGeneral-Italic;">h</span><span style="display: inline-block; width: 0px; height: 2.484em;"></span></span><span style="position: absolute; top: -2.024em; left: 0.497em;"><span class="mi" id="MathJax-Span-314" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">y</span><span style="display: inline-block; width: 0px; height: 2.174em;"></span></span></span></span><span class="mo" id="MathJax-Span-315" style="font-family: STIXGeneral-Regular;">)</span></span><span style="display: inline-block; width: 0px; height: 2.484em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.268em; vertical-align: -0.411em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-35">(h_x,h_y)</script> is found?</p>
</blockquote>

<p>The size of the model template in number of HOG cell can be computed in several way; one is simply:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">modelWidth = <span class="hljs-built_in">size</span>(trainHog, <span class="hljs-number">2</span>) ;
modelHeight = <span class="hljs-built_in">size</span>(trainHog, <span class="hljs-number">1</span>) ;</code></pre>

<p>Now we have enough information to compute the bounding box as follows:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">detection = <span class="hljs-matrix">[
  x - <span class="hljs-number">0.5</span> ;
  y - <span class="hljs-number">0.5</span> ;
  x + hogCellSize * modelWidth - <span class="hljs-number">0.5</span> ;
  y + hogCellSize * modelHeight - <span class="hljs-number">0.5</span> ;]</span> ;</code></pre>

<p><strong>Note:</strong> the bounding box encloses exactly all the pixel of the HOG template. In MATLAB, pixel centers have integer coordinates and pixel borders are at a distance <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-36-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-316" style="width: 2.446em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.007em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.685em 1000em 2.802em -0.483em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-317"><span class="mo" id="MathJax-Span-318" style="font-family: STIXGeneral-Regular;">±</span><span class="mn" id="MathJax-Span-319" style="font-family: STIXGeneral-Regular;">1</span><span class="texatom" id="MathJax-Span-320"><span class="mrow" id="MathJax-Span-321"><span class="mo" id="MathJax-Span-322" style="font-family: STIXGeneral-Regular;">/</span></span></span><span class="mn" id="MathJax-Span-323" style="font-family: STIXGeneral-Regular;">2</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.066em; vertical-align: -0.177em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-36">\pm1/2</script>.</p>

<blockquote>
  <p><strong>Question:</strong> Use the example code to plot the image and overlay the bounding box of the detected object. Did it work as expected?</p>
</blockquote>

<h2 id="part2">Part 2: Multiple scales and learning with an SVM</h2>

<p>In this second part, we will: (i) extend the detector to search objects at multiple scales and (ii) learn a better model using a support vector machine. Let’s start by loading the data as needed:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">setup ;
targetClass = <span class="hljs-string">'mandatory'</span> ;
loadData(targetClass) ;</code></pre>

<p>The <code>mandatory</code> target class is simply the union of all mandatory traffic signs.</p>

<h3 id="step2" class="1">Step 2.1: Multi-scale detection</h3>

<p>Objects exist in images at sizes different from the one of the learned template. In order to find objects of all sizes, we scale the image up and down and search the object over and over again.</p>

<p>The set of searched scale is defined as follows:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Scale space configuraiton</span>
minScale = -<span class="hljs-number">1</span> ;
maxScale = <span class="hljs-number">3</span> ;
numOctaveSubdivisions = <span class="hljs-number">3</span> ;
scales = <span class="hljs-number">2.</span>^<span class="hljs-built_in">linspace</span>(...
  minScale,...
  maxScale,...
  numOctaveSubdivisions*(maxScale-minScale+<span class="hljs-number">1</span>)) ;</code></pre>

<p>Given the model <code>w</code>, as determined in Part I, we use the function <code>detectAtMultipleScales</code> in order to search the object at multiple scales:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">detection = detectAtMultipleScales(im, w, hogCellSize, scales) ;</code></pre>

<p>Note that the function generates a figure as it runs, so prepare a new figure before running it using the <code>figure</code> command if you do not want your current figure to be deleted.</p>

<blockquote>
  <p><strong>Question:</strong> Open and study the <code>detectAtMultipleScales</code> function. Convince yourself that it is the same code as before, but operated after rescaling the image a number of times. </p>
  
  <p><strong>Question:</strong> Visualized the resulting detection using the supplied example code. Did it work? If not, can you make sense of the errors?</p>
  
  <p><strong>Question:</strong> Look at the array of <code>scores</code> maps generated by <code>detectAtMultipleScales</code> using the example code. Do they make sense? Is there anything wrong?</p>
</blockquote>

<h3 id="step-22-collect-positive-and-negative-training-data">Step 2.2: Collect positive and negative training data</h3>

<p>The model learned so far is too weak to work well. It is now time to use an SVM to learn a better one. In order to do so, we need to prepare suitable data. We already have positive examples (features extracted from object patches):</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Collect positive training data</span>
pos = trainHog ;</code></pre>

<p>Ino order to collect negative examples (features extracted from non-object patches), we loop through a number of training images and sample patches uniformly:</p>

<blockquote>
  <p><strong>Task:</strong> Identify the code that extract these patches in <code>example2.m</code> and make sure you understand it.</p>
  
  <p><strong>Question:</strong> How many negative examples are we collecting?</p>
</blockquote>

<h3 id="step-23-learn-a-model-with-an-svm">Step 2.3: Learn a model with an SVM</h3>

<p>Now thaw we have the data, we can learn an SVM model. To this end we will use the <code>vl_svmtrain</code> function. This function requires the data to be in a <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-37-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-324" style="width: 3.161em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.597em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.708em 1000em 2.74em -0.539em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-325"><span class="mi" id="MathJax-Span-326" style="font-family: STIXGeneral-Italic;">D</span><span class="mo" id="MathJax-Span-327" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="mi" id="MathJax-Span-328" style="font-family: STIXGeneral-Italic; padding-left: 0.25em;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.06em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.963em; vertical-align: -0.102em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-37">D \times N</script> matrix, where <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-38-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-329" style="width: 0.946em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.767em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.708em 1000em 2.715em -0.539em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-330"><span class="mi" id="MathJax-Span-331" style="font-family: STIXGeneral-Italic;">D</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.933em; vertical-align: -0.071em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-38">D</script> are the feature dimensions and <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-39-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-332" style="width: 0.946em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.767em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.708em 1000em 2.73em -0.551em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-333"><span class="mi" id="MathJax-Span-334" style="font-family: STIXGeneral-Italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.06em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.951em; vertical-align: -0.09em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-39">N</script> the number of training points. This is done by:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Pack the data into a matrix with one datum per column</span>
x = <span class="hljs-built_in">cat</span>(<span class="hljs-number">4</span>, pos, neg) ;
x = <span class="hljs-built_in">reshape</span>(x, <span class="hljs-matrix">[]</span>, numPos + numNeg) ;</code></pre>

<p>We also need a vector of binary labels, +1 for positive points and -1 for negative ones:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Create a vector of binary labels</span>
y = <span class="hljs-matrix">[ones(<span class="hljs-number">1</span>, size(pos,<span class="hljs-number">4</span>)) -ones(<span class="hljs-number">1</span>, size(neg,<span class="hljs-number">4</span>))]</span> ;</code></pre>

<p>Finally, we need to set the parameter <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-40-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-335" style="width: 0.589em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.472em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.683em 1000em 2.731em -0.543em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-336"><span class="mi" id="MathJax-Span-337" style="font-family: STIXGeneral-Italic;">λ</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.983em; vertical-align: -0.091em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-40">\lambda</script> of the SVM solver. For reason that will become clearer later, we use instead the equivalent <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-41-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-338" style="width: 0.875em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.708em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.695em 1000em 2.733em -0.465em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-339"><span class="mi" id="MathJax-Span-340" style="font-family: STIXGeneral-Italic;">C<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.022em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.97em; vertical-align: -0.093em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-41">C</script> parameter:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">numPos = <span class="hljs-built_in">size</span>(pos,<span class="hljs-number">4</span>) ;
numNeg = <span class="hljs-built_in">size</span>(neg,<span class="hljs-number">4</span>) ;
C = <span class="hljs-number">10</span> ;
lambda = <span class="hljs-number">1</span> / (C * (numPos + numNeg)) ;</code></pre>

<p>Learning the SVM is then a one-liner:</p>

<pre class="prettyprint"><code class=" hljs cs">% Learn the SVM <span class="hljs-keyword">using</span> an SVM solver
w = vl_svmtrain(x,y,lambda,<span class="hljs-string">'epsilon'</span>,<span class="hljs-number">0.01</span>,<span class="hljs-string">'verbose'</span>) ;</code></pre>

<blockquote>
  <p><strong>Question:</strong> Visualize the learned model <code>w</code> using the supplied code. Does it differ from the naive model learned before? How?</p>
</blockquote>

<h3 id="step-24-evaluate-the-learned-model">Step 2.4: Evaluate the learned model</h3>

<p>Use the <code>detectAtMultipleScales</code> seen above to evaluate the new SVM-based model.</p>

<blockquote>
  <p><strong>Question:</strong> Does the learned model perform better than the naive average?</p>
  
  <p><strong>Task:</strong> Try different images. Does this detector work all the times? If not, what types of mistakes do you see? Are these mistakes reasonable?</p>
</blockquote>

<h2 id="part3">Part 3: Multiple objects and evaluation</h2>

<h3 id="step-31-multiple-detections">Step 3.1: Multiple detections</h3>

<p>Detecting at multiple scales is insufficient: we must also allow for more than one object occurrence in the image. In order to to so, the package include a suitalbe <code>detect</code> functin. This function is similar to <code>detectAtMultipleScales</code>, but it returns the top 1000 detector responses rather than just the top one:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Compute detections</span>
<span class="hljs-matrix">[detections, scores]</span> = detect(im, w, hogCellSize, scales) ;</code></pre>

<blockquote>
  <p><strong>Task:</strong> Open and study <code>detect.m</code>. Make sure that you understand how it works.</p>
  
  <p><strong>Question:</strong> Why do we want to return so many responses? In practice, it is unlikely that more than an handful of object occurrences may be contained in any given image…</p>
</blockquote>

<p>A single object occurrence generates multiple detector responses at nearby image locations and scales. In order to eliminate these redundant detections, we use a <em>non-maxima suppression</em> algorithm. This is implemented by the <code>boxsuppress.m</code> MATLAB m-file. The algorithm is simple: start from the highest-scoring detection, then remove any other detection whose overlap<a href="#fn:overlap" id="fnref:overlap" title="See footnote" class="footnote">2</a> is greater than a threshold. The function returns a boolean vector <code>keep</code> of detections to preserve:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Non-maxima suppression</span>
keep = boxsuppress(detections, scores, <span class="hljs-number">0.25</span>) ;

detections = detections(:, keep) ;
scores = scores(keep) ;</code></pre>

<p>For efficiency, after non-maxima suppression we keep just ten responses (as we do not expect more than a few objects in any image):</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Further keep only top detections</span>
detections = detections(:, <span class="hljs-number">1</span>:<span class="hljs-number">10</span>) ;
scores = scores(<span class="hljs-number">1</span>:<span class="hljs-number">10</span>) ;</code></pre>

<h3 id="step-32-detector-evaluation">Step 3.2: Detector evaluation</h3>

<p>We are now going to look at properly evaluating our detector. We use the <a href="http://pascallin.ecs.soton.ac.uk/challenges/VOC/voc2012/devkit_doc.pdf">PASCAL VOC criterion</a>, computing <em>Average Precision (AP)</em>. Consider a test image containing a number of ground truth object occurrences <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-42-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-341" style="width: 5.804em; display: inline-block;"><span style="display: inline-block; position: relative; width: 4.782em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.685em 1000em 2.963em -0.483em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-342"><span class="mo" id="MathJax-Span-343" style="font-family: STIXGeneral-Regular;">(</span><span class="msubsup" id="MathJax-Span-344"><span style="display: inline-block; position: relative; width: 0.96em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.921em -0.523em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-345" style="font-family: STIXGeneral-Italic;">g</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -1.943em; left: 0.531em;"><span class="mn" id="MathJax-Span-346" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">1</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-347" style="font-family: STIXGeneral-Regular;">,</span><span class="mo" id="MathJax-Span-348" style="font-family: STIXGeneral-Regular; padding-left: 0.188em;">…</span><span class="mo" id="MathJax-Span-349" style="font-family: STIXGeneral-Regular; padding-left: 0.188em;">,</span><span class="msubsup" id="MathJax-Span-350" style="padding-left: 0.188em;"><span style="display: inline-block; position: relative; width: 1.138em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.921em -0.523em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-351" style="font-family: STIXGeneral-Italic;">g</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -1.943em; left: 0.531em;"><span class="mi" id="MathJax-Span-352" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">m</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-353" style="font-family: STIXGeneral-Regular;">)</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.261em; vertical-align: -0.371em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-42">(g_1,\dots,g_m)</script> and a list <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-43-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-354" style="width: 3.232em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.656em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.678em 1000em 2.892em -0.483em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-355"><span class="mo" id="MathJax-Span-356" style="font-family: STIXGeneral-Regular;">(</span><span class="msubsup" id="MathJax-Span-357"><span style="display: inline-block; position: relative; width: 0.842em; height: 0px;"><span style="position: absolute; clip: rect(1.678em 1000em 2.726em -0.508em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-358" style="font-family: STIXGeneral-Italic;">b</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.531em;"><span class="mi" id="MathJax-Span-359" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-360" style="font-family: STIXGeneral-Regular;">,</span><span class="msubsup" id="MathJax-Span-361" style="padding-left: 0.188em;"><span style="display: inline-block; position: relative; width: 0.724em; height: 0px;"><span style="position: absolute; clip: rect(1.919em 1000em 2.728em -0.515em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-362" style="font-family: STIXGeneral-Italic;">s</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.413em;"><span class="mi" id="MathJax-Span-363" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-364" style="font-family: STIXGeneral-Regular;">)</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.183em; vertical-align: -0.286em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-43">(b_i,s_i)</script> of candidate detections <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-44-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-365" style="width: 1.018em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.826em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.265em 1000em 2.46em -0.508em); top: -2.125em; left: 0em;"><span class="mrow" id="MathJax-Span-366"><span class="msubsup" id="MathJax-Span-367"><span style="display: inline-block; position: relative; width: 0.842em; height: 0px;"><span style="position: absolute; clip: rect(1.678em 1000em 2.726em -0.508em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-368" style="font-family: STIXGeneral-Italic;">b</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.531em;"><span class="mi" id="MathJax-Span-369" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.125em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.16em; vertical-align: -0.262em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-44">b_i</script> with score <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-45-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-370" style="width: 0.875em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.708em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.506em 1000em 2.46em -0.515em); top: -2.125em; left: 0em;"><span class="mrow" id="MathJax-Span-371"><span class="msubsup" id="MathJax-Span-372"><span style="display: inline-block; position: relative; width: 0.724em; height: 0px;"><span style="position: absolute; clip: rect(1.919em 1000em 2.728em -0.515em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-373" style="font-family: STIXGeneral-Italic;">s</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.413em;"><span class="mi" id="MathJax-Span-374" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.125em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.869em; vertical-align: -0.262em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-45">s_i</script>. The following algorithm converts this data into a list of labels and scores <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-46-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-375" style="width: 3.161em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.597em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.685em 1000em 2.965em -0.483em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-376"><span class="mo" id="MathJax-Span-377" style="font-family: STIXGeneral-Regular;">(</span><span class="msubsup" id="MathJax-Span-378"><span style="display: inline-block; position: relative; width: 0.724em; height: 0px;"><span style="position: absolute; clip: rect(1.919em 1000em 2.728em -0.515em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-379" style="font-family: STIXGeneral-Italic;">s</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.413em;"><span class="mi" id="MathJax-Span-380" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-381" style="font-family: STIXGeneral-Regular;">,</span><span class="msubsup" id="MathJax-Span-382" style="padding-left: 0.188em;"><span style="display: inline-block; position: relative; width: 0.783em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.921em -0.555em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-383" style="font-family: STIXGeneral-Italic;">y</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -1.943em; left: 0.472em;"><span class="mi" id="MathJax-Span-384" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-385" style="font-family: STIXGeneral-Regular;">)</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.262em; vertical-align: -0.373em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-46">(s_i,y_i)</script> that can be used to compute a precision-recall curve, for example using VLFeat <em>vl_pr</em> function. The algorithm, implemented by <code>evalDetections.m</code>, is as follows:</p>

<ol>
<li>The candidate detections <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-47-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-386" style="width: 3.232em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.656em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.678em 1000em 2.892em -0.483em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-387"><span class="mo" id="MathJax-Span-388" style="font-family: STIXGeneral-Regular;">(</span><span class="msubsup" id="MathJax-Span-389"><span style="display: inline-block; position: relative; width: 0.842em; height: 0px;"><span style="position: absolute; clip: rect(1.678em 1000em 2.726em -0.508em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-390" style="font-family: STIXGeneral-Italic;">b</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.531em;"><span class="mi" id="MathJax-Span-391" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-392" style="font-family: STIXGeneral-Regular;">,</span><span class="msubsup" id="MathJax-Span-393" style="padding-left: 0.188em;"><span style="display: inline-block; position: relative; width: 0.724em; height: 0px;"><span style="position: absolute; clip: rect(1.919em 1000em 2.728em -0.515em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-394" style="font-family: STIXGeneral-Italic;">s</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.413em;"><span class="mi" id="MathJax-Span-395" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-396" style="font-family: STIXGeneral-Regular;">)</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.183em; vertical-align: -0.286em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-47">(b_i,s_i)</script> are sorted by decreasing score <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-48-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-397" style="width: 0.875em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.708em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.506em 1000em 2.46em -0.515em); top: -2.125em; left: 0em;"><span class="mrow" id="MathJax-Span-398"><span class="msubsup" id="MathJax-Span-399"><span style="display: inline-block; position: relative; width: 0.724em; height: 0px;"><span style="position: absolute; clip: rect(1.919em 1000em 2.728em -0.515em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-400" style="font-family: STIXGeneral-Italic;">s</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.413em;"><span class="mi" id="MathJax-Span-401" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.125em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.869em; vertical-align: -0.262em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-48">s_i</script>.</li>
<li>For each candidate detection in order: <br>
a. If there is a matching ground truth detection <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-49-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-402" style="width: 1.018em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.826em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.507em 1000em 2.69em -0.523em); top: -2.125em; left: 0em;"><span class="mrow" id="MathJax-Span-403"><span class="msubsup" id="MathJax-Span-404"><span style="display: inline-block; position: relative; width: 0.842em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.921em -0.523em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-405" style="font-family: STIXGeneral-Italic;">g</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -1.943em; left: 0.531em;"><span class="mi" id="MathJax-Span-406" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">j<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.001em;"></span></span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.125em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.146em; vertical-align: -0.541em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-49">g_j</script> (<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-50-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-407" style="width: 6.946em; display: inline-block;"><span style="display: inline-block; position: relative; width: 5.726em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.678em 1000em 3.103em -0.502em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-408"><span class="mi" id="MathJax-Span-409" style="font-family: STIXGeneral-Regular;">overlap</span><span class="mo" id="MathJax-Span-410"></span><span class="mo" id="MathJax-Span-411" style="font-family: STIXGeneral-Regular;">(</span><span class="msubsup" id="MathJax-Span-412"><span style="display: inline-block; position: relative; width: 0.842em; height: 0px;"><span style="position: absolute; clip: rect(1.678em 1000em 2.726em -0.508em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-413" style="font-family: STIXGeneral-Italic;">b</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.531em;"><span class="mi" id="MathJax-Span-414" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-415" style="font-family: STIXGeneral-Regular;">,</span><span class="msubsup" id="MathJax-Span-416" style="padding-left: 0.188em;"><span style="display: inline-block; position: relative; width: 0.842em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.921em -0.523em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-417" style="font-family: STIXGeneral-Italic;">g</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -1.943em; left: 0.531em;"><span class="mi" id="MathJax-Span-418" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">j<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.001em;"></span></span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-419" style="font-family: STIXGeneral-Regular;">)</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.438em; vertical-align: -0.541em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-50">\operatorname{overlap}(b_i,g_j)</script><a href="#fn:overlap" id="fnref:overlap" title="See footnote" class="footnote">3</a> larger than 50%), the candidate detection is considered positive (<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-51-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-420" style="width: 3.946em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.247em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.685em 1000em 2.965em -0.555em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-421"><span class="msubsup" id="MathJax-Span-422"><span style="display: inline-block; position: relative; width: 0.783em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.921em -0.555em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-423" style="font-family: STIXGeneral-Italic;">y</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -1.943em; left: 0.472em;"><span class="mi" id="MathJax-Span-424" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-425" style="font-family: STIXGeneral-Regular; padding-left: 0.313em;">=</span><span class="mo" id="MathJax-Span-426" style="font-family: STIXGeneral-Regular; padding-left: 0.313em;">+</span><span class="mn" id="MathJax-Span-427" style="font-family: STIXGeneral-Regular;">1</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.262em; vertical-align: -0.373em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-51">y_i=+1</script>). Furthermore, the ground truth detection is <em>removed from the list</em> and not considered further. <br>
b. Otherwise ,the candidate detection is negative (<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-52-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-428" style="width: 3.946em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.247em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.685em 1000em 2.965em -0.555em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-429"><span class="msubsup" id="MathJax-Span-430"><span style="display: inline-block; position: relative; width: 0.783em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.921em -0.555em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-431" style="font-family: STIXGeneral-Italic;">y</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -1.943em; left: 0.472em;"><span class="mi" id="MathJax-Span-432" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-433" style="font-family: STIXGeneral-Regular; padding-left: 0.313em;">=</span><span class="mo" id="MathJax-Span-434" style="font-family: STIXGeneral-Regular; padding-left: 0.313em;">−</span><span class="mn" id="MathJax-Span-435" style="font-family: STIXGeneral-Regular;">1</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.262em; vertical-align: -0.373em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-52">y_i=-1</script>).</li>
<li>Any ground truth detection that remains unassigned is considered a positive object <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-53-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-436" style="width: 3.946em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.247em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.685em 1000em 2.965em -0.555em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-437"><span class="msubsup" id="MathJax-Span-438"><span style="display: inline-block; position: relative; width: 0.783em; height: 0px;"><span style="position: absolute; clip: rect(1.92em 1000em 2.921em -0.555em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-439" style="font-family: STIXGeneral-Italic;">y</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -1.943em; left: 0.472em;"><span class="mi" id="MathJax-Span-440" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-441" style="font-family: STIXGeneral-Regular; padding-left: 0.313em;">=</span><span class="mo" id="MathJax-Span-442" style="font-family: STIXGeneral-Regular; padding-left: 0.313em;">+</span><span class="mn" id="MathJax-Span-443" style="font-family: STIXGeneral-Regular;">1</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.262em; vertical-align: -0.373em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-53">y_i=+1</script> recalled with a score equal to <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-54-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-444" style="width: 4.446em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.66em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.919em 1000em 2.873em -0.515em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-445"><span class="msubsup" id="MathJax-Span-446"><span style="display: inline-block; position: relative; width: 0.724em; height: 0px;"><span style="position: absolute; clip: rect(1.919em 1000em 2.728em -0.515em); top: -2.538em; left: 0em;"><span class="mi" id="MathJax-Span-447" style="font-family: STIXGeneral-Italic;">s</span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span><span style="position: absolute; top: -2.034em; left: 0.413em;"><span class="mi" id="MathJax-Span-448" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">i</span><span style="display: inline-block; width: 0px; height: 2.184em;"></span></span></span></span><span class="mo" id="MathJax-Span-449" style="font-family: STIXGeneral-Regular; padding-left: 0.313em;">=</span><span class="mo" id="MathJax-Span-450" style="font-family: STIXGeneral-Regular; padding-left: 0.313em;">−</span><span class="mi" id="MathJax-Span-451" style="font-family: STIXGeneral-Regular;">∞</span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.869em; vertical-align: -0.262em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-54">s_i=-\infty</script>.</li>
</ol>

<blockquote>
  <p><strong>Question:</strong> Answer the following: (i) Why are ground truth detections considred only once? (ii) What happens if an object is detected twice?</p>
</blockquote>

<p>In order to apply this algorithm, we first need to find the ground truth bounding boxes in the test image:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Find all the objects in the target image</span>
s = <span class="hljs-built_in">find</span>(strcmp(testImages<span class="hljs-cell">{<span class="hljs-number">1</span>}</span>, testBoxImages)) ;
gtBoxes = testBoxes(:, s) ;</code></pre>

<p>Then <code>evalDetections</code> can be used:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% No example is considered difficult</span>
gtDifficult = false(<span class="hljs-number">1</span>, <span class="hljs-built_in">numel</span>(s)) ;

<span class="hljs-comment">% PASCAL-like evaluation</span>
matches = evalDetections(...
  gtBoxes, gtDifficult, ...
  detections, scores) ;</code></pre>

<p>The <code>gtDifficult</code> flags can be used to mark some ground truth object occurrence as <em>difficult</em> and hence ignored in the evaluation. This is used in the PASCAL VOC challenge, but not here (i.e. no object occurrence is considered difficult).</p>

<p><code>evalDetections</code> returns a <code>matches</code> structure with several field. We focus here on <code>matches.detBoxFlags</code>: this contains a +1 for each detections that was found to be correct and -1 otherwise. We use this to visualize the detection errors:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Visualization</span>
figure(<span class="hljs-number">1</span>) ; clf ;
imagesc(im) ; axis equal ; hold on ;
vl_plotbox(detections(:, <span class="hljs-transposed_variable">matches.</span>detBoxFlags==+<span class="hljs-number">1</span>), <span class="hljs-string">'g'</span>, <span class="hljs-string">'linewidth'</span>, <span class="hljs-number">2</span>) ;
vl_plotbox(detections(:, <span class="hljs-transposed_variable">matches.</span>detBoxFlags==-<span class="hljs-number">1</span>), <span class="hljs-string">'r'</span>, <span class="hljs-string">'linewidth'</span>, <span class="hljs-number">2</span>) ;
vl_plotbox(gtBoxes, <span class="hljs-string">'b'</span>, <span class="hljs-string">'linewidth'</span>, <span class="hljs-number">1</span>) ;
axis off ;</code></pre>

<blockquote>
  <p><strong>Task:</strong> Use the supplied example code to evaluate the detector on one image. Look carefully at the output and convince yourself that it makes sense.</p>
</blockquote>

<p>Now Plot the PR curve:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">figure(<span class="hljs-number">2</span>) ; clf ;
vl_pr(<span class="hljs-transposed_variable">matches.</span>labels, <span class="hljs-transposed_variable">matches.</span>scores) ;</code></pre>

<blockquote>
  <p><strong>Question:</strong> There are a large number of errors in each image. Should you worry?  Is what manner is the PR curve affected? How would you eliminate the vast majority of those in a practice?</p>
</blockquote>

<h3 id="step-33-evaluation-on-multiple-images">Step 3.3: Evaluation on multiple images</h3>

<p>Evaluation is typically done on multiple images rather than just one. This is implemented by the <code>evalModel.m</code> m-file.</p>

<blockquote>
  <p><strong>Task:</strong> Open <code>evalModel.m</code> and make sure you understand the main steps of the evaluation procedure.</p>
</blockquote>

<p>Use the supplied example code to run the evaluation on the entiere test set:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">matches = evaluateModel(testImages, testBoxes, testBoxImages, ...
  w, hogCellSize, scales) ;</code></pre>

<p><strong>Note:</strong> The function process an image per time, visualizing the results as it progresses. The PR curve is the result of the <em>accumulation</em> of the detections obtained thus far.</p>

<blockquote>
  <p><strong>Task:</strong> Open the <code>evaluateModel.m</code> file in MATLAB and add a breakpoint right at the end of the for loop. Now run the evaluation code again and look at each image individually (use <code>dbcont</code> to go to the next image). Check out the correct and incorrect matches in each image and their ranking and the effect of this in the cumulative precision-recall curve.</p>
</blockquote>

<h2 id="part4">Part 4: Hard negative mining</h2>

<p>This part explores more advanced learning methods. So far, the SVM has been learned using a small and randomly sampled number of negative examples. However, in principle, every single patch that does not contain the object can be considered as a negative sample. These are of course too many to be used in practice; unfortunately, random sampling is ineffective as the most interesting (confusing) negative samples are a very small and special subset of all the possible ones.</p>

<p><em>Hard negative mining</em> is a simple technique that allows finding a small set of key negative examples. The idea is simple: we start by training a model without any negative at all, and then we alternate between evaluating the model on the training data to find erroneous responses and adding the corresponding examples to the training set.</p>

<h3 id="stage4" class="1">Step 4.1: Train with hard negative mining</h3>

<p>Use the supplied code in <code>example4.m</code> to run hard negative mining. The code repeats SVM training, as seen above, a number of times, progressively increasing the size of the <code>neg</code> array containing the negative samples. This is updated using the output of:</p>

<pre class="prettyprint"><code class="language-matlab hljs "> <span class="hljs-matrix">[matches, moreNeg]</span> = ...
    evaluateModel(...
    vl_colsubset(<span class="hljs-transposed_variable">trainImages'</span>, schedule(t), <span class="hljs-string">'beginning'</span>), ...
    trainBoxes, trainBoxImages, ...
    w, hogCellSize, scales) ;</code></pre>

<p>Here <code>moreNeg</code> contains the HOG features of the top (highest scoring and hence most confusing) image patches in the supplied training images.</p>

<blockquote>
  <p><strong>Task:</strong> Examine <code>evaluateModel.m</code> again to understand how hard negatives are extracted.</p>
  
  <p><strong>Question:</strong> What is the purpose of the construct <code>vl_colsubset(trainImages', schedule(t), 'beginning')</code>? Why do you think we visit more negative images in later iterations?</p>
</blockquote>

<p>The next step is to fuse the new negative set with the old one:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Add negatives</span>
neg = <span class="hljs-built_in">cat</span>(<span class="hljs-number">4</span>, neg, moreNeg) ;</code></pre>

<p>Note that hard negative mining could select the same negatives at different iterations; the following code squashes these duplicates:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-comment">% Remove negative duplicates</span>
z = <span class="hljs-built_in">reshape</span>(neg, <span class="hljs-matrix">[]</span>, <span class="hljs-built_in">size</span>(neg,<span class="hljs-number">4</span>)) ;
<span class="hljs-matrix">[~,keep]</span> = unique(<span class="hljs-transposed_variable">z'</span>,<span class="hljs-string">'stable'</span>,<span class="hljs-string">'rows'</span>) ;
neg = neg(:,:,:,keep) ;</code></pre>

<h3 id="step-42-evaluate-the-model-on-the-test-data">Step 4.2: Evaluate the model on the test data</h3>

<p>Once hard negative mining and training are done, we are ready to evaluate the model on the <em>test</em> data (note that the model is evaluated on the <em>training</em> data for mining). As before:</p>

<pre class="prettyprint"><code class="language-matlab hljs ">evaluateModel(...
    testImages, testBoxes, testBoxImages, ...
    w, hogCellSize, scales) ;</code></pre>

<h2 id="part-5-train-your-own-object-detector">Part 5: Train your own object detector</h2>

<p><strong>Skip on fast track</strong></p>

<p>In this last part, you will learn your own object detector. To this end, open and look at <code>exercise5.m</code>. You will need to prepare the following data:</p>

<h3 id="step-51-preparing-the-training-data">Step 5.1: Preparing the training data</h3>

<ul>
<li>A folder <code>data/myPositives</code> containing files <code>image1.jpeg</code>, <code>image2.jpeg</code>, …, each containing a single cropped occurence of the target object. These crops can be of any size, but should be roughly square.</li>
<li>A folder <code>data/myNegatives</code> containing images <code>image1.jpeg</code>, <code>image2.jpeg</code>, …, that <em>do not</em> contain the target object at all.</li>
<li>A test image <code>data/myTestImage.jpeg</code> containing the target object. This should not be one of the training images.</li>
</ul>

<p>Run the code in <code>example5.m</code> to check that your training data looks right.</p>

<blockquote>
  <p><strong>Task:</strong> Understand the limitations of this simple detector and choose a target object that has a good chance of being learnable. </p>
</blockquote>

<p><strong>Hint:</strong> Note in particular that object instances must be similar and roughly aligned</p>

<h3 id="step-52-learn-the-model">Step 5.2: Learn the model</h3>

<p>Use the supplied code to learn an SVM model for your object using hard negative mining as in <a href="#stage4.1">Stage 4.1</a>.</p>

<h3 id="step-53-test-the-model">Step 5.3: Test the model</h3>

<p>Use the supplied code to evaluate the SVM model on a test image and visualize the result as in <a href="#stage2.1">Stage 2.1</a>.</p>

<blockquote>
  <p><strong>Task:</strong> Make sure you get sensible results. Go back to step 5.1 if needed and ajdust your data.</p>
</blockquote>

<p><strong>Hint:</strong> For debugging purposes, try using one of your training images as test. Does it work at least in this case?</p>

<div class="footnotes"><hr><ol><li id="fn:nn">This is part of the MatConvNet toolbox for convolutional neural networks. Nevertheless, there is no neural network discussed here. <a href="#fnref:nn" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:overlap">Measured as area of the intersection over are of the union: <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-55-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-452" style="width: 6.946em; display: inline-block;"><span style="display: inline-block; position: relative; width: 5.726em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.685em 1000em 2.746em -0.464em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-453"><span class="texatom" id="MathJax-Span-454"><span class="mrow" id="MathJax-Span-455"><span class="mo" id="MathJax-Span-456" style="font-family: STIXGeneral-Regular;">|</span></span></span><span class="mi" id="MathJax-Span-457" style="font-family: STIXGeneral-Italic;">A</span><span class="mo" id="MathJax-Span-458" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">∩</span><span class="mi" id="MathJax-Span-459" style="font-family: STIXGeneral-Italic; padding-left: 0.25em;">B</span><span class="texatom" id="MathJax-Span-460"><span class="mrow" id="MathJax-Span-461"><span class="mo" id="MathJax-Span-462" style="font-family: STIXGeneral-Regular;">|</span></span></span><span class="texatom" id="MathJax-Span-463"><span class="mrow" id="MathJax-Span-464"><span class="mo" id="MathJax-Span-465" style="font-family: STIXGeneral-Regular;">/</span></span></span><span class="texatom" id="MathJax-Span-466"><span class="mrow" id="MathJax-Span-467"><span class="mo" id="MathJax-Span-468" style="font-family: STIXGeneral-Regular;">|</span></span></span><span class="mi" id="MathJax-Span-469" style="font-family: STIXGeneral-Italic;">A</span><span class="mo" id="MathJax-Span-470" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">∪</span><span class="mi" id="MathJax-Span-471" style="font-family: STIXGeneral-Italic; padding-left: 0.25em;">B</span><span class="texatom" id="MathJax-Span-472"><span class="mrow" id="MathJax-Span-473"><span class="mo" id="MathJax-Span-474" style="font-family: STIXGeneral-Regular;">|</span></span></span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.998em; vertical-align: -0.109em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-55">|A\cap B|/|A \cup B|</script>. <a href="#fnref:overlap" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:overlap">Measured as area of the intersection over are of the union: <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-56-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-475" style="width: 6.946em; display: inline-block;"><span style="display: inline-block; position: relative; width: 5.726em; height: 0px; font-size: 121%;"><span style="position: absolute; clip: rect(1.685em 1000em 2.746em -0.464em); top: -2.538em; left: 0em;"><span class="mrow" id="MathJax-Span-476"><span class="texatom" id="MathJax-Span-477"><span class="mrow" id="MathJax-Span-478"><span class="mo" id="MathJax-Span-479" style="font-family: STIXGeneral-Regular;">|</span></span></span><span class="mi" id="MathJax-Span-480" style="font-family: STIXGeneral-Italic;">A</span><span class="mo" id="MathJax-Span-481" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">∩</span><span class="mi" id="MathJax-Span-482" style="font-family: STIXGeneral-Italic; padding-left: 0.25em;">B</span><span class="texatom" id="MathJax-Span-483"><span class="mrow" id="MathJax-Span-484"><span class="mo" id="MathJax-Span-485" style="font-family: STIXGeneral-Regular;">|</span></span></span><span class="texatom" id="MathJax-Span-486"><span class="mrow" id="MathJax-Span-487"><span class="mo" id="MathJax-Span-488" style="font-family: STIXGeneral-Regular;">/</span></span></span><span class="texatom" id="MathJax-Span-489"><span class="mrow" id="MathJax-Span-490"><span class="mo" id="MathJax-Span-491" style="font-family: STIXGeneral-Regular;">|</span></span></span><span class="mi" id="MathJax-Span-492" style="font-family: STIXGeneral-Italic;">A</span><span class="mo" id="MathJax-Span-493" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">∪</span><span class="mi" id="MathJax-Span-494" style="font-family: STIXGeneral-Italic; padding-left: 0.25em;">B</span><span class="texatom" id="MathJax-Span-495"><span class="mrow" id="MathJax-Span-496"><span class="mo" id="MathJax-Span-497" style="font-family: STIXGeneral-Regular;">|</span></span></span></span><span style="display: inline-block; width: 0px; height: 2.538em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.998em; vertical-align: -0.109em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-56">|A\cap B|/|A \cup B|</script>. <a href="#fnref:overlap" title="Return to article" class="reversefootnote">↩</a></li></ol></div></div></body>
</html>